---
layout: post
title: "双指针问题"
date: 2025-02-01 00:00:00
description: 使用双指针解决一系列问题
tags: code algorithm acwing
categories: learning-notebook
---

# 最长连续不重复子序列
## 解题思路
### 双指针算法的样子

```cpp
for(int i = 0, j = 0; i < n; i ++){
	while(j < i && check(i, j)) j ++;
	// 每道题的具体逻辑
}
```
- **最核心的性质**：可以优化
### 核心思想

```cpp
for(int i = 0; i < n; i ++){
	for(int j = 0; j < n; j ++)
		//代码实现的逻辑
}
```
- 可以将$\Omega(n^2)$的朴素算法优化到$\Omega(n)$

### 最长连续不重复子序列
![Snipaste_2025-01-31_12-38-16.png](https://cdn.acwing.com/media/article/image/2025/01/31/477965_372d0c12df-Snipaste_2025-01-31_12-38-16.png) 
- 给定绿色右侧指针为当前的j（对于j的定义为：j往左能到的符合条件的、最远的地方），绿色左侧指针为假设我们还有一个j能更加左，但是这个与j的定义相矛盾，所以我们说j到i之间的距离就是最长连续不重复子序列的长度
- 基本代码模版为：

```cpp
// 朴素做法，复杂度为O(n)
for(int i = 0; i < n; i ++){
	for(int j = 0; j < n; j ++){
		if(check(i, j)){
			res = max(res, i - j + 1);
		}
	}
}
// 双指针算法
// 发现一些单调性质，并利用
for(int i = 0; i < n; i ++){
	while(j <= i && check(i, j)){
		j ++;
	}

	res = max(res, i - j + 1);

}
```
## 代码实现
### 双指针算法最基本的应用
- 提取用空格分隔开的单词

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(){
	char str[100];
	gets(str);
//	这里一定要使用gets()，使用cin会导致第一个空格之后的字符没有被提取到 
//	cout << str << endl;
//	cin 使用 >> 运算符的时候，默认会跳过空白字符，直到遇到下一个空白字符停止读取
// 	所以cin只能读取到第一个单词 
	
	int n = strlen(str);
	
	for(int i = 0; i < n; i ++){
		int j = i;
		while(j < n && str[j] != ' '){
			
			j ++;
			
		}
		
		for(int k = i; k < j; k ++){
			cout << str[k];
//			注意 k ++ 这个语句是在一个循环块执行结束后执行 
		}
		cout << endl;
		
		i = j;
	}
	
	
	return 0;
	
}
```
![[Pasted image 20250131121856.png]]
### 最长连续不重复子序列

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 100;
int n;
int a[N], s[N];

int main(){
    cin >> n;
    for(int i = 0; i < n; i ++){
        cin >> a[i];
    }
    
    int res = 0;
    for(int i = 0, j = 0; i < n; i ++){
        s[a[i]] ++;
        while(s[a[i]] > 1){
            s[a[j]] --;
            j ++;
        }
        
        res = max(res,i - j + 1);
    }
    
    
    cout << res << endl;
    
    return 0;
}
```
# 数组元素的目标和
## 实现思想
- 暴力做法（容易超时）
- 找单调性：
	- 主要思路是`for(int i = 0; i < n; i ++)`，找到一个`j`，使得$A_i+B_j\geq x$，同时`j`的下标是最小的
	- 当有满足条件的下标`i, j`出现的时候，直接输出答案并`break`
## 实现代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 100;
int n, m, x;
int a[N], b[N];

int main(){
    cin >> n >> m >> x;
    for(int i = 0; i < n; i ++){
        cin >> a[i];
    }
    for(int i = 0; i < m; i ++){
        cin >> b[i];
    }
    
    for(int i = 0, j = m - 1; i < n; i ++){
        
        while(j >= 0 && a[i] + b[j] > x){
            j --;
        }
        if(a[i] + b[j] == x){
            cout << i << " " << j << endl;
            break;
        }
    }
}
```