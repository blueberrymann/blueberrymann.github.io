---
layout: post
title: "双指针问题"
date: 2025-02-01 00:00:00
description: 使用双指针解决一系列问题
tags: code algorithm acwing
categories: learning-notebook
---

# 最长连续不重复子序列
## 解题思路
### 双指针算法的样子

```cpp
for(int i = 0, j = 0; i < n; i ++){
	while(j < i && check(i, j)) j ++;
	// 每道题的具体逻辑
}
```
- **最核心的性质**：可以优化
### 核心思想

```cpp
for(int i = 0; i < n; i ++){
	for(int j = 0; j < n; j ++)
		//代码实现的逻辑
}
```
- 可以将$\Omega(n^2)$的朴素算法优化到$\Omega(n)$

### 最长连续不重复子序列
![Snipaste_2025-01-31_12-38-16.png](https://cdn.acwing.com/media/article/image/2025/01/31/477965_372d0c12df-Snipaste_2025-01-31_12-38-16.png) 
- 给定绿色右侧指针为当前的j（对于j的定义为：j往左能到的符合条件的、最远的地方），绿色左侧指针为假设我们还有一个j能更加左，但是这个与j的定义相矛盾，所以我们说j到i之间的距离就是最长连续不重复子序列的长度
- 基本代码模版为：

```cpp
// 朴素做法，复杂度为O(n)
for(int i = 0; i < n; i ++){
	for(int j = 0; j < n; j ++){
		if(check(i, j)){
			res = max(res, i - j + 1);
		}
	}
}
// 双指针算法
// 发现一些单调性质，并利用
for(int i = 0; i < n; i ++){
	while(j <= i && check(i, j)){
		j ++;
	}

	res = max(res, i - j + 1);

}
```
## 代码实现
### 双指针算法最基本的应用
- 提取用空格分隔开的单词

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(){
	char str[100];
	gets(str);
//	这里一定要使用gets()，使用cin会导致第一个空格之后的字符没有被提取到 
//	cout << str << endl;
//	cin 使用 >> 运算符的时候，默认会跳过空白字符，直到遇到下一个空白字符停止读取
// 	所以cin只能读取到第一个单词 
	
	int n = strlen(str);
	
	for(int i = 0; i < n; i ++){
		int j = i;
		while(j < n && str[j] != ' '){
			
			j ++;
			
		}
		
		for(int k = i; k < j; k ++){
			cout << str[k];
//			注意 k ++ 这个语句是在一个循环块执行结束后执行 
		}
		cout << endl;
		
		i = j;
	}
	
	
	return 0;
	
}
```
![[Pasted image 20250131121856.png]]
### 最长连续不重复子序列

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 100;
int n;
int a[N], s[N];

int main(){
    cin >> n;
    for(int i = 0; i < n; i ++){
        cin >> a[i];
    }
    
    int res = 0;
    for(int i = 0, j = 0; i < n; i ++){
        s[a[i]] ++;
        while(s[a[i]] > 1){
            s[a[j]] --;
            j ++;
        }
        
        res = max(res,i - j + 1);
    }
    
    
    cout << res << endl;
    
    return 0;
}
```
# 数组元素的目标和
## 实现思想
- 暴力做法（容易超时）
- 找单调性：
	- 主要思路是`for(int i = 0; i < n; i ++)`，找到一个`j`，使得$A_i+B_j\geq x$，同时`j`的下标是最小的
	- 当有满足条件的下标`i, j`出现的时候，直接输出答案并`break`
## 实现代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 100;
int n, m, x;
int a[N], b[N];

int main(){
    cin >> n >> m >> x;
    for(int i = 0; i < n; i ++){
        cin >> a[i];
    }
    for(int i = 0; i < m; i ++){
        cin >> b[i];
    }
    
    for(int i = 0, j = m - 1; i < n; i ++){
        
        while(j >= 0 && a[i] + b[j] > x){
            j --;
        }
        if(a[i] + b[j] == x){
            cout << i << " " << j << endl;
            break;
        }
    }
}
```

## 力扣习题
### 移动零
![](/assets/img/screenshot/移动零.png)
#### 实现思路&需要注意的点
- 初始化两个指针`l`和`r`
- 当`r`指针指向的数字为0时，指针`r`向后移动
- 当`r`指针指向的数字不为0时，指针`l, r`向后移动，并将`l, r`分别指向的两个数字进行交换
- 进行以上操作之后的效果为：
  - 指针`l`左侧全为非零数字
  - 指针`r`和`l`之间都是零
- 当指针`r`移动到末尾时，操作完毕，此时的数字已经满足要求
#### 实现代码

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = 0;
        while(right < n){
            // left 和 right指针之间都是0
            if(nums[right]){
                swap(nums[left], nums[right]);
                left ++;
            }
            right ++;

        }
    }
};
```

### 盛水最多的容器
![](/assets/img/screenshot/盛水最多的容器.png)
#### 实现思路&需要注意的点
- 我们可以发现，在高度中，影响装的水的体积的因素，是两个高度中较矮的那个，即“木桶效应”
##### 进行数学证明
1. 给定`heights`数组存储所有木板的长度
2. 假设初始化两个指针`l`和`r`，其中`l`位于数组下标0处，`r`位于数组最末端（下标为数组长度减1）
3. 假设`heights[l]<heights[r]`，那么我们可以得到，当前装载水的体积为`heights[l] * (r - l)`。
4. 如果我们此时移动`r`指针，那么水的体积会怎么变化呢？从下面的推断，可以发现移动`r`指针（高度较高的那个）是不会让水的体积变大的
    - 如果`heights[r_new] <= heights[r]`，那么新的水体积`min(heights[r_new], heights[l]) <= heights[l] * (r - l)`
    - 如果`heights[r_new] > heights[r]`，那么新的水的体积`min(heights[r_new], heights[l]) > heights[l] * (r - l)`
5. 我们应该移动`l`指针（高度较低的指针），才可能使得水体积变大
    - 如果`heights[l_new] <= heights[l]`，那么新的水体积一定小于等于原来的
    - 如果`heights[l_new] > heights[l]`，那么新的水体积是大于原来水体积的
6. 综上所述，应该移动指向高度较低的指针，并向对侧移动（`l ++`和`r --`），才能找到能盛水最多的容器壁

#### 实现代码

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        // int ans = 0;
        int n = height.size();
        int l = 0, r = n - 1;
        int ans = (n - 1) * min(height[l], height[r]);
        while(l < r){
            int h = min(height[r], height[l]);
            ans = max(ans, (r - l) * h);
            if(height[l] > height[r])
                h = height[r --];
            else
                h = height[l ++];
            
        }
        return ans;
    }
};
```