<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://blueberrymann.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://blueberrymann.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-28T14:30:14+00:00</updated><id>https://blueberrymann.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">2025第一周蓝桥杯每日一题</title><link href="https://blueberrymann.github.io/blog/2025/0223-0227-%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="alternate" type="text/html" title="2025第一周蓝桥杯每日一题"/><published>2025-02-25T13:36:07+00:00</published><updated>2025-02-25T13:36:07+00:00</updated><id>https://blueberrymann.github.io/blog/2025/0223-0227-%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/0223-0227-%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><![CDATA[<h1 id="农夫约翰的奶酪块">农夫约翰的奶酪块</h1> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/screenshot/%E5%86%9C%E5%A4%AB%E7%BA%A6%E7%BF%B0%E7%9A%84%E5%A5%B6%E9%85%AA%E5%9D%97-480.webp 480w,/assets/img/screenshot/%E5%86%9C%E5%A4%AB%E7%BA%A6%E7%BF%B0%E7%9A%84%E5%A5%B6%E9%85%AA%E5%9D%97-800.webp 800w,/assets/img/screenshot/%E5%86%9C%E5%A4%AB%E7%BA%A6%E7%BF%B0%E7%9A%84%E5%A5%B6%E9%85%AA%E5%9D%97-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/screenshot/%E5%86%9C%E5%A4%AB%E7%BA%A6%E7%BF%B0%E7%9A%84%E5%A5%B6%E9%85%AA%E5%9D%97.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="农夫约翰的奶酪块" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="知识点">知识点</h2> <h2 id="解题思路">解题思路</h2> <ul> <li>一个<code class="language-plaintext highlighter-rouge">1 * 1 * N</code>的方块的插入方向有三种： <ul> <li>沿x轴方向</li> <li>沿y轴方向</li> <li>沿z轴方向</li> </ul> </li> <li>所以用三个数组表示某一个面背后的的缺口的数量</li> <li>如果某一个面背后缺口的数量已经达到<code class="language-plaintext highlighter-rouge">n</code>了，那么说明可以增加一种插入方案</li> </ul> <h2 id="实现代码">实现代码</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span><span class="o">=</span> <span class="mi">1100</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">&gt;&gt;</span> <span class="n">z</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">++</span> <span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">++</span> <span class="n">b</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">++</span> <span class="n">c</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">++</span><span class="p">;</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <h1 id="哞叫时间">哞叫时间</h1> <h2 id="知识点-1">知识点</h2> <ul> <li>枚举</li> <li><code class="language-plaintext highlighter-rouge">printf</code>和<code class="language-plaintext highlighter-rouge">scanf</code>函数 <ul> <li><code class="language-plaintext highlighter-rouge">printf</code>函数</li> <li><code class="language-plaintext highlighter-rouge">scanf</code>函数</li> </ul> </li> </ul> <h2 id="解题思路-1">解题思路</h2> <ul> <li>根据题意，我们要统计出现次数大于等于<code class="language-plaintext highlighter-rouge">m</code>次的<code class="language-plaintext highlighter-rouge">abb</code>子串</li> <li>总体思路：将字符串中的每个字符进行修改操作，之后遍历以这个字符分别为最后一个字符，倒数第二个字符，和第一个字符的长度为3的子串 <ul> <li>时间复杂度：$\Omega(25 \times N)$</li> </ul> </li> <li>初始化两个数组： <ul> <li><code class="language-plaintext highlighter-rouge">int cnt[a][b]</code>：记录每个<code class="language-plaintext highlighter-rouge">abb</code>型子串出现的次数</li> <li><code class="language-plaintext highlighter-rouge">int st[N][N]</code>：记录每个<code class="language-plaintext highlighter-rouge">abb</code>型是否可以作为答案的状态</li> </ul> </li> <li>建立<code class="language-plaintext highlighter-rouge">update</code>函数 <ul> <li>输入参数为：<code class="language-plaintext highlighter-rouge">int l, int r, int v</code></li> <li>对该范围内长度为3的子串的<code class="language-plaintext highlighter-rouge">cnt</code>数组进行更新，对于满足条件的<code class="language-plaintext highlighter-rouge">abb</code>数组在其<code class="language-plaintext highlighter-rouge">cnt</code>数值上<code class="language-plaintext highlighter-rouge">+ v</code></li> </ul> </li> <li>遍历每个字符，将字符修改为除自己其他25个英文字母，对上述的三种子串利用<code class="language-plaintext highlighter-rouge">update</code>函数进行判断</li> <li>最后遍历<code class="language-plaintext highlighter-rouge">cnt</code>和<code class="language-plaintext highlighter-rouge">st</code>数组，输出<code class="language-plaintext highlighter-rouge">res</code>和符合条件的<code class="language-plaintext highlighter-rouge">abb</code>型子串</li> </ul> <h2 id="实现代码-1">实现代码</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">20200</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>

<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cnt</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">M</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">st</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">M</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">r</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
        <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span><span class="p">){</span>
            <span class="n">cnt</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">st</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>


    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="p">;</span>
    <span class="c1">// 先统计原串</span>
    <span class="n">update</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 再统计修改一个字符之后的abb型数量</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
        <span class="kt">char</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">update</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span> <span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">t</span><span class="p">){</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="n">update</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">update</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">update</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span> <span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="n">ans</span> <span class="o">++</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span> <span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%c%c%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">);</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="acwing"/><category term="每日一题"/><category term="蓝桥杯"/><summary type="html"><![CDATA[记录蓝桥杯每日一题的解题思路的求解代码]]></summary></entry><entry><title type="html">20250225力扣每日一题</title><link href="https://blueberrymann.github.io/blog/2025/0225-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="alternate" type="text/html" title="20250225力扣每日一题"/><published>2025-02-25T13:36:07+00:00</published><updated>2025-02-25T13:36:07+00:00</updated><id>https://blueberrymann.github.io/blog/2025/0225-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/0225-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><![CDATA[<div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-480.webp 480w,/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-800.webp 800w,/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="设计内存分配器" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="知识点">知识点</h2> <h2 id="解题思路">解题思路</h2> <ul> <li>对于每次<code class="language-plaintext highlighter-rouge">allocate</code>操作，无论如何都要遍历数组一次，所以我们选择在遍历时，记录数组中空余位置的数量 <ul> <li>当遇到<code class="language-plaintext highlighter-rouge">0</code>值是，计数器<code class="language-plaintext highlighter-rouge">cnt</code>加一</li> <li>当遇到非零值时，计数器<code class="language-plaintext highlighter-rouge">cnt</code>归零</li> </ul> </li> <li>对于每个元素，判断<code class="language-plaintext highlighter-rouge">size</code>是否等于当前<code class="language-plaintext highlighter-rouge">cnt</code>大小 <ul> <li>如果等于，那么就返回<code class="language-plaintext highlighter-rouge">i - size + 1</code></li> <li>如果遍历结束后，也不等于，那么就返回<code class="language-plaintext highlighter-rouge">-1</code></li> </ul> </li> </ul> <h2 id="实现代码">实现代码</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Allocator</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Allocator</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memory</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">allocate</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mID</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="o">++</span> <span class="n">count</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">size</span><span class="p">){</span>
                    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">++</span><span class="p">){</span>
                        <span class="n">memory</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mID</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">freeMemory</span><span class="p">(</span><span class="kt">int</span> <span class="n">mID</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">mID</span><span class="p">){</span>
                <span class="o">++</span> <span class="n">count</span><span class="p">;</span>
                <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">memory</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/**
 * Your Allocator object will be instantiated and called as such:
 * Allocator* obj = new Allocator(n);
 * int param_1 = obj-&gt;allocate(size,mID);
 * int param_2 = obj-&gt;freeMemory(mID);
 */</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="leetcode"/><category term="每日一题"/><category term="模拟"/><summary type="html"><![CDATA[记录每日一题的解题思路的求解代码]]></summary></entry><entry><title type="html">20250225力扣每日一题</title><link href="https://blueberrymann.github.io/blog/2025/0227-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="alternate" type="text/html" title="20250225力扣每日一题"/><published>2025-02-25T13:36:07+00:00</published><updated>2025-02-25T13:36:07+00:00</updated><id>https://blueberrymann.github.io/blog/2025/0227-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/0227-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><![CDATA[<h2 id="知识点">知识点</h2> <ul> <li><code class="language-plaintext highlighter-rouge">list</code>类型： <ul> <li>双向链表结构：每个节点包含数据和指向前后的指针</li> <li>非连续内存：不同于<code class="language-plaintext highlighter-rouge">vector</code>和<code class="language-plaintext highlighter-rouge">array</code>，<code class="language-plaintext highlighter-rouge">list</code>不提供随机访问</li> <li>插入和删除高效</li> <li>增删改操作</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 在链表尾部添加元素</span>
<span class="n">myList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

<span class="c1">// 在链表头部添加元素</span>
<span class="n">myList</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// 移除链表尾部元素</span>
<span class="n">myList</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

<span class="c1">// 移除链表头部元素</span>
<span class="n">myList</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>

<span class="c1">// 清空整个链表</span>
<span class="n">myList</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

<span class="c1">// 在指定位置插入元素</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="o">++</span><span class="n">it</span><span class="p">;</span>  <span class="c1">// 移动到第二个位置</span>
<span class="n">myList</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>                 <span class="c1">// 在第二个位置插入值100</span>
<span class="n">myList</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>              <span class="c1">// 在第二个位置插入3个值为200的元素</span>
<span class="n">myList</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>           <span class="c1">// 插入初始化列表 (C++11)</span>
<span class="n">myList</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">anotherList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">anotherList</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>  <span class="c1">// 插入另一个容器的区间</span>

<span class="c1">// 移除元素</span>
<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">myList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="o">++</span><span class="n">pos</span><span class="p">;</span>  <span class="o">++</span><span class="n">pos</span><span class="p">;</span>  <span class="c1">// 移动到第三个位置</span>
<span class="n">myList</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>                       <span class="c1">// 移除第三个元素</span>
<span class="n">myList</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">myList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myList</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 移除所有元素</span>

<span class="c1">// 移除特定值的所有元素</span>
<span class="n">myList</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>                       <span class="c1">// 移除所有值为42的元素</span>

<span class="c1">// 按条件移除元素 (C++11)</span>
<span class="n">myList</span><span class="p">.</span><span class="n">remove_if</span><span class="p">([](</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>  <span class="c1">// 移除所有负数</span>

<span class="c1">// 替换元素</span>
<span class="n">std</span><span class="o">::</span><span class="n">replace</span><span class="p">(</span><span class="n">myList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">43</span><span class="p">);</span>  <span class="c1">// 将所有42替换为43</span>

<span class="c1">// C++11中的原位构造</span>
<span class="n">myList</span><span class="p">.</span><span class="n">emplace_front</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>          <span class="c1">// 在前端原位构造元素</span>
<span class="n">myList</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>           <span class="c1">// 在后端原位构造元素</span>
<span class="n">myList</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">args</span><span class="p">...);</span>      <span class="c1">// 在指定位置原位构造元素</span>

<span class="c1">// 连接两个链表（移动元素，不复制）</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">list1</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">list1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">list2</span><span class="p">);</span>       <span class="c1">// 现在list1={1,2,3,4,5,6}，list2为空</span>

<span class="c1">// 将单个元素从一个链表移到另一个链表</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="o">++</span><span class="n">it</span><span class="p">;</span>  <span class="c1">// 指向第二个元素</span>
<span class="n">list2</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">list2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">list1</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span> <span class="c1">// 将list1的第二个元素移动到list2开头</span>

<span class="c1">// 将区间元素从一个链表移到另一个链表</span>
<span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">list1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">list1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>                   <span class="c1">// 移动到第四个元素位置</span>
<span class="n">list2</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">list2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">list1</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span> <span class="c1">// 移动[start,end)范围的元素</span>

</code></pre></div></div> <ul> <li>迭代器的使用方法</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 声明一个list&lt;char&gt;的迭代器变量</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">cursor</span><span class="p">;</span>

<span class="c1">// 将迭代器初始化为指向list的开始</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="n">myList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

<span class="c1">// 将迭代器初始化为指向list的结束（实际上是最后一个元素之后的位置）</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="n">myList</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

<span class="c1">// 访问迭代器指向的元素</span>
<span class="kt">char</span> <span class="n">currentChar</span> <span class="o">=</span> <span class="o">*</span><span class="n">cursor</span><span class="p">;</span>

<span class="c1">// 移动迭代器到下一个元素</span>
<span class="n">cursor</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 或 ++cursor;</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>  <span class="c1">// C++11引入的方式</span>

<span class="c1">// 移动迭代器到前一个元素</span>
<span class="n">cursor</span><span class="o">--</span><span class="p">;</span>  <span class="c1">// 或 --cursor;</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="n">prev</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>  <span class="c1">// C++11引入的方式</span>

<span class="c1">// 检查两个迭代器是否相等（指向同一位置）</span>
<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span> <span class="o">==</span> <span class="n">myList</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 已经遍历到列表末尾</span>
<span class="p">}</span>

</code></pre></div></div> <div class="row mt-3"> <div class="col-sm-12"> <object data="/assets/pdf/your_document.pdf" type="application/pdf" width="100%" height="500px"> <p>It appears you don't have a PDF plugin for this browser. You can <a href="/assets/pdf/List_In_Cpp.pdf">click here to download the PDF file.</a> </p> </object> </div> </div> <h2 id="解题思路">解题思路</h2> <h2 id="实现代码">实现代码</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">TextEditor</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">editor</span><span class="p">;</span>
    <span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">cursor</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">TextEditor</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">editor</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">addText</span><span class="p">(</span><span class="n">string</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">:</span> <span class="n">text</span><span class="p">)</span>
            <span class="n">editor</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">deleteText</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="n">editor</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">k</span> <span class="o">--</span><span class="p">){</span>
            <span class="n">editor</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">prev</span><span class="p">(</span><span class="n">cursor</span><span class="p">));</span>
            <span class="n">cnt</span> <span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">string</span> <span class="nf">cursorLeft</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="n">editor</span><span class="p">.</span><span class="n">begin</span><span class="p">()){</span>
            <span class="n">k</span> <span class="o">--</span><span class="p">;</span>
            <span class="n">cursor</span> <span class="o">=</span> <span class="n">prev</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">head</span> <span class="o">=</span> <span class="n">cursor</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">editor</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">prev</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">string</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">cursor</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">string</span> <span class="nf">cursorRight</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="n">editor</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
            <span class="n">k</span> <span class="o">--</span><span class="p">;</span>
            <span class="n">cursor</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">head</span> <span class="o">=</span> <span class="n">cursor</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">editor</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">prev</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">string</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">cursor</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
 * Your TextEditor object will be instantiated and called as such:
 * TextEditor* obj = new TextEditor();
 * obj-&gt;addText(text);
 * int param_2 = obj-&gt;deleteText(k);
 * string param_3 = obj-&gt;cursorLeft(k);
 * string param_4 = obj-&gt;cursorRight(k);
 */</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="leetcode"/><category term="每日一题"/><category term="模拟"/><summary type="html"><![CDATA[记录每日一题的解题思路的求解代码]]></summary></entry><entry><title type="html">20250224力扣每日一题</title><link href="https://blueberrymann.github.io/blog/2025/0224-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="alternate" type="text/html" title="20250224力扣每日一题"/><published>2025-02-24T13:36:07+00:00</published><updated>2025-02-24T13:36:07+00:00</updated><id>https://blueberrymann.github.io/blog/2025/0224-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/0224-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><![CDATA[<div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81-480.webp 480w,/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81-800.webp 800w,/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="设计有序流" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="知识点">知识点</h2> <ul> <li>对于一个元素类型为容器的<code class="language-plaintext highlighter-rouge">vector</code>数组，我们可以使用下标和<code class="language-plaintext highlighter-rouge">empty()</code>的方式来判断数组中的某一个位置是否为空</li> <li><code class="language-plaintext highlighter-rouge">vector</code>的<code class="language-plaintext highlighter-rouge">resize</code>操作 <ul> <li>增大容器：新增元素会被初始化</li> <li>缩小容器：超出新大小的元素会被销毁</li> </ul> </li> </ul> <h2 id="解题思路">解题思路</h2> <ul> <li>在初始化操作中，我们将类的成员变量数组<code class="language-plaintext highlighter-rouge">stream</code>使用<code class="language-plaintext highlighter-rouge">resize()</code>操作将数组扩大到指定大小</li> <li>在<code class="language-plaintext highlighter-rouge">insert</code>操作中，将指定位置上的数组元素插入对应的字符穿</li> <li>在输出阶段，首先判断<code class="language-plaintext highlighter-rouge">ptr</code>有没有越界，如果没有越界，则判断<code class="language-plaintext highlighter-rouge">ptr</code>指向的元素是否为空</li> <li>如果既没有越界也不为空过，那么将对应的字符串输入<code class="language-plaintext highlighter-rouge">ans</code>数组并返回</li> </ul> <h2 id="实现代码">实现代码</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">OrderedStream</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">OrderedStream</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stream</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">idKey</span><span class="p">,</span> <span class="n">string</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stream</span><span class="p">[</span><span class="n">idKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">stream</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">stream</span><span class="p">[</span><span class="n">ptr</span><span class="p">].</span><span class="n">empty</span><span class="p">()){</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">ptr</span><span class="p">]);</span>
            <span class="n">ptr</span> <span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>

    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">stream</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * Your OrderedStream object will be instantiated and called as such:
 * OrderedStream* obj = new OrderedStream(n);
 * vector&lt;string&gt; param_1 = obj-&gt;insert(idKey,value);
 */</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="leetcode"/><category term="每日一题"/><category term="模拟"/><summary type="html"><![CDATA[记录每日一题的解题思路的求解代码]]></summary></entry><entry><title type="html">20250223力扣每日一题</title><link href="https://blueberrymann.github.io/blog/2025/0223-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="alternate" type="text/html" title="20250223力扣每日一题"/><published>2025-02-23T01:36:07+00:00</published><updated>2025-02-23T01:36:07+00:00</updated><id>https://blueberrymann.github.io/blog/2025/0223-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/0223-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><![CDATA[<div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8-480.webp 480w,/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8-800.webp 800w,/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/screenshot/%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="设计跳表" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="实现代码">实现代码</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">MAX_LEVEL</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">double</span> <span class="n">P_FACTOR</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">SkiplistNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">SkiplistNode</span> <span class="o">*&gt;</span> <span class="n">forward</span><span class="p">;</span>
    <span class="n">SkiplistNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_maxLevel</span> <span class="o">=</span> <span class="n">MAX_LEVEL</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="p">),</span> <span class="n">forward</span><span class="p">(</span><span class="n">_maxLevel</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Skiplist</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">SkiplistNode</span> <span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
    <span class="n">mt19937</span> <span class="n">gen</span><span class="p">{</span><span class="n">random_device</span><span class="p">{}()};</span>
    <span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">dis</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">Skiplist</span><span class="p">()</span><span class="o">:</span> <span class="n">head</span><span class="p">(</span><span class="k">new</span> <span class="nf">SkiplistNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">level</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SkiplistNode</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 找到第 i 层小于且最接近 target 的元素*/</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="cm">/* 检测当前元素的值是否等于 target */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">SkiplistNode</span> <span class="o">*&gt;</span> <span class="n">update</span><span class="p">(</span><span class="n">MAX_LEVEL</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
        <span class="n">SkiplistNode</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 找到第 i 层小于且最接近 num 的元素*/</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">randomLevel</span><span class="p">();</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="n">SkiplistNode</span> <span class="o">*</span><span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">SkiplistNode</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lv</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span>
            <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">erase</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">SkiplistNode</span> <span class="o">*&gt;</span> <span class="n">update</span><span class="p">(</span><span class="n">MAX_LEVEL</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
        <span class="n">SkiplistNode</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 找到第 i 层小于且最接近 num 的元素*/</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="cm">/* 如果值不存在则返回 false */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span> <span class="o">||</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */</span>
            <span class="n">update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">delete</span> <span class="n">curr</span><span class="p">;</span>
        <span class="cm">/* 更新当前的 level */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">level</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">randomLevel</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="cm">/* 随机生成 lv */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">dis</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">P_FACTOR</span> <span class="o">&amp;&amp;</span> <span class="n">lv</span> <span class="o">&lt;</span> <span class="n">MAX_LEVEL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lv</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">lv</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>



</code></pre></div></div>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="leetcode"/><category term="每日一题"/><category term="跳表"/><summary type="html"><![CDATA[记录每日一题的解题思路的求解代码]]></summary></entry><entry><title type="html">20250222力扣每日一题</title><link href="https://blueberrymann.github.io/blog/2025/0222-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="alternate" type="text/html" title="20250222力扣每日一题"/><published>2025-02-22T01:36:07+00:00</published><updated>2025-02-22T01:36:07+00:00</updated><id>https://blueberrymann.github.io/blog/2025/0222-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/0222-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><![CDATA[<div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/screenshot/%E7%BB%9F%E8%AE%A1%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE-480.webp 480w,/assets/img/screenshot/%E7%BB%9F%E8%AE%A1%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE-800.webp 800w,/assets/img/screenshot/%E7%BB%9F%E8%AE%A1%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/screenshot/%E7%BB%9F%E8%AE%A1%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="统计相似字符串对的数目" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="知识点">知识点</h2> <h2 id="解题思路">解题思路</h2> <h3 id="我的思路">我的思路</h3> <ul> <li>首先遍历词序列，将每个词中的字母存入哈希集合中。 <ul> <li>因为哈希集合中的元素都是独一无二的，所以我们可以通过每个词对应的哈希集合判断这两个词是不是相似词</li> </ul> </li> <li>使用哈希表存储词下标和词对应的哈希集合的一一对应关心</li> <li>遍历判断两个词对应的哈希集合是否相等 <ul> <li>如果相等，则说明两个词相似</li> <li>如果不相等，则说明两个词不相似</li> </ul> </li> </ul> <h2 id="实现代码">实现代码</h2> <h3 id="我的代码">我的代码</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">similarPairs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">wordMap</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="n">wordMap</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">i</span><span class="p">,</span> <span class="p">{}});</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span> <span class="o">++</span><span class="p">){</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">wordMap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">(</span><span class="n">index</span><span class="p">)){</span>
                    <span class="n">wordMap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">wordMap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">wordMap</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">ans</span> <span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="leetcode"/><category term="每日一题"/><category term="哈希"/><summary type="html"><![CDATA[记录每日一题的解题思路的求解代码]]></summary></entry><entry><title type="html">20250221力扣每日一题</title><link href="https://blueberrymann.github.io/blog/2025/0221-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="alternate" type="text/html" title="20250221力扣每日一题"/><published>2025-02-21T01:36:07+00:00</published><updated>2025-02-21T01:36:07+00:00</updated><id>https://blueberrymann.github.io/blog/2025/0221-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/0221-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><![CDATA[<div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/screenshot/%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97-480.webp 480w,/assets/img/screenshot/%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97-800.webp 800w,/assets/img/screenshot/%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/screenshot/%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="用地毯覆盖后的最少白色砖块" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="知识点">知识点</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">static</code>关键字表示这个常量<code class="language-plaintext highlighter-rouge">INF</code>是静态的；静态成员属于类本身，无论创建多少个类的实例，<code class="language-plaintext highlighter-rouge">INF</code>都只有一个实例，并且可以在类的所有对象中使用</li> <li><code class="language-plaintext highlighter-rouge">constexpr</code>关键字表示这个常量是一个编译时的常量，<code class="language-plaintext highlighter-rouge">INF</code>的值在编译时就已经确定</li> <li><code class="language-plaintext highlighter-rouge">int INF = 0x3f3f3f3f</code>在算法竞赛常被用于“无穷大”的替代值</li> </ul> <h2 id="解题思路">解题思路</h2> <ul> <li>求地毯无法覆盖的白色方块的最小数量</li> <li>因为不用考虑左侧已铺设的地毯的位置，只需要关注剩余地毯的数量，所以可以考虑使用动态规划</li> <li>动态规划从两个大方向考虑： <ul> <li>状态表示：<code class="language-plaintext highlighter-rouge">d[i][j]</code>表示在前<code class="language-plaintext highlighter-rouge">i</code>个砖块上用了<code class="language-plaintext highlighter-rouge">j</code>块地毯后，最少的剩余的白色方块还有多少 <ul> <li>集合：在前<code class="language-plaintext highlighter-rouge">i</code>个砖块上用了<code class="language-plaintext highlighter-rouge">j</code>块地毯之后，剩余白色方块的数量</li> <li>属性：最小值</li> </ul> </li> <li>状态计算：将<code class="language-plaintext highlighter-rouge">d[i][j]</code>集合进行分类，按照当前方砖是否被地毯覆盖来分类 <ul> <li>当前方砖被地毯覆盖：<code class="language-plaintext highlighter-rouge">d[max(0, i - carpetLen)][j - 1]</code></li> <li>当前方砖未被地毯覆盖：<code class="language-plaintext highlighter-rouge">d[i - 1][j] + (floor[i] == '1')</code> <ul> <li>如果当前方砖为白色砖块，那么就要<code class="language-plaintext highlighter-rouge">++</code></li> </ul> </li> </ul> </li> </ul> </li> <li>获得转移方程</li> </ul> \[d[i][j]=min(d[i - 1][j] + (floor[i] == \text{'1'}),d[i - carpetLen][j - 1])\] <h2 id="实现代码">实现代码</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minimumWhiteTiles</span><span class="p">(</span><span class="n">string</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numCarpets</span><span class="p">,</span> <span class="kt">int</span> <span class="n">carpetLen</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">floor</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numCarpets</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INF</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">numCarpets</span><span class="p">;</span> <span class="n">j</span> <span class="o">++</span><span class="p">){</span>
            <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">floor</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'1'</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">numCarpets</span><span class="p">;</span> <span class="n">j</span> <span class="o">++</span><span class="p">){</span>
                <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">floor</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'1'</span><span class="p">);</span>
                <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">carpetLen</span><span class="p">)][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">numCarpets</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="leetcode"/><category term="每日一题"/><category term="动态规划"/><summary type="html"><![CDATA[记录每日一题的解题思路的求解代码]]></summary></entry><entry><title type="html">20250220力扣每日一题</title><link href="https://blueberrymann.github.io/blog/2025/0220-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="alternate" type="text/html" title="20250220力扣每日一题"/><published>2025-02-20T03:27:07+00:00</published><updated>2025-02-20T03:27:07+00:00</updated><id>https://blueberrymann.github.io/blog/2025/0220-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/0220-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><![CDATA[<div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/screenshot/%E5%A5%87%E5%81%B6%E4%BD%8D%E6%95%B0-480.webp 480w,/assets/img/screenshot/%E5%A5%87%E5%81%B6%E4%BD%8D%E6%95%B0-800.webp 800w,/assets/img/screenshot/%E5%A5%87%E5%81%B6%E4%BD%8D%E6%95%B0-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/screenshot/%E5%A5%87%E5%81%B6%E4%BD%8D%E6%95%B0.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="奇偶位数" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="知识点">知识点</h2> <ul> <li>位运算符<code class="language-plaintext highlighter-rouge">&amp;</code>：可以用来判断一个数的奇偶性； <ul> <li>如果<code class="language-plaintext highlighter-rouge">n &amp; 1</code>的结果是<code class="language-plaintext highlighter-rouge">1</code>，那么这个数就是奇数；结果为<code class="language-plaintext highlighter-rouge">0</code>，那么这个数就是偶数</li> </ul> </li> <li>异或运算符<code class="language-plaintext highlighter-rouge">^</code>：可以让一个变量的值在<code class="language-plaintext highlighter-rouge">0</code>和<code class="language-plaintext highlighter-rouge">1</code>之间交替变化</li> </ul> <h2 id="解题思路">解题思路</h2> <h3 id="题解思路">题解思路</h3> <ul> <li>初始化变量<code class="language-plaintext highlighter-rouge">i</code>用来表示当前数位是奇数位还是偶数位</li> <li>当前数位如果为1，就在数组对应下标<code class="language-plaintext highlighter-rouge">+1</code></li> </ul> <h3 id="我的思路">我的思路</h3> <ul> <li>模拟</li> </ul> <h2 id="实现代码">实现代码</h2> <h3 id="题解代码">题解代码</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">evenOddBit</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">){</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">i</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="我的代码">我的代码</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">evenOddBit</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">){</span>
            <span class="n">t</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">));</span>
            <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">even</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">odd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// even是偶数，odd是奇数</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">--</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">even</span> <span class="o">++</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">odd</span> <span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">even</span><span class="p">,</span> <span class="n">odd</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="leetcode"/><category term="每日一题"/><category term="位运算"/><summary type="html"><![CDATA[记录每日一题的解题思路的求解代码]]></summary></entry><entry><title type="html">面向语义的数据质量评价方法</title><link href="https://blueberrymann.github.io/blog/2025/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95/" rel="alternate" type="text/html" title="面向语义的数据质量评价方法"/><published>2025-02-19T07:52:45+00:00</published><updated>2025-02-19T07:52:45+00:00</updated><id>https://blueberrymann.github.io/blog/2025/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95/"><![CDATA[<p>面向语义的数据质量评价方法（2025.02.19之后）</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/screenshot/%E9%9D%A2%E5%90%91%E8%AF%AD%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95%EF%BC%882025.02.19%E4%B9%8B%E5%90%8E%EF%BC%89.svg" sizes="95vw"/> <img src="/assets/img/screenshot/%E9%9D%A2%E5%90%91%E8%AF%AD%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95%EF%BC%882025.02.19%E4%B9%8B%E5%90%8E%EF%BC%89.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="面向语义的数据质量评价方法（2025.02.19之后）" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h1 id="对齐度">对齐度</h1> <h1 id="重叠度">重叠度</h1> <h2 id="deduplicating-training-data-makes-language-models-better">Deduplicating Training Data Makes Language Models Better</h2> <h3 id="n-gram">n-gram</h3> <ul> <li>一个n-gram就是</li> </ul> <h3 id="jaccard系数">Jaccard系数</h3> <h3 id="minhash">MinHash</h3> <h1 id="困惑度">困惑度</h1> <h1 id="多样性">多样性</h1> <h2 id="beyond-scale-the-diversity-coefficient-as-a-data-quality-metric-for-variability-in-natural-language-data">Beyond Scale: The Diversity Coefficient as a Data Quality Metric for Variability in Natural Language Data</h2> <h3 id="摘要">摘要</h3> <ul> <li>提出了一种让数据的variability形式化的度量方法 —— <strong>Diversity Coefficient</strong></li> <li>经过大量数据分析，论文证明了当数据集中概念标签增加时，<strong>Diversity Coefficient</strong>也增加。可以正确反映与我们直观感受上多样性变化</li> <li>经过试验验证，<strong>Diversity Coefficient</strong>可以描述下游模型评估性能的有用方面</li> </ul> <h3 id="method-the-diversity-coefficient-for-natural-language">Method: the Diversity Coefficient for Natural Language</h3> <h4 id="知识点补充">知识点补充</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Task2Vec</code>:</li> </ul> <h4 id="1-computing-task2vec-embeddings-for-text">1. Computing Task2Vec Embeddings For Text</h4> <ul> <li>Task2Vec嵌入向量；</li> </ul> <h4 id="2">2.</h4> <h4 id="3">3.</h4>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="acwing"/><summary type="html"><![CDATA[在2025.02.19之前，我查找了一些关于数据质量评价方法的资料，但是感觉都是一些“方法”，并不像NLP中的那些有具体的数学公式。此次进一步调研，旨在找到像困惑度，对齐度，重叠度等量化指标以及衡量它们的最新方法]]></summary></entry><entry><title type="html">20250219力扣每日一题</title><link href="https://blueberrymann.github.io/blog/2025/0219-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="alternate" type="text/html" title="20250219力扣每日一题"/><published>2025-02-19T02:27:07+00:00</published><updated>2025-02-19T02:27:07+00:00</updated><id>https://blueberrymann.github.io/blog/2025/0219-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98</id><content type="html" xml:base="https://blueberrymann.github.io/blog/2025/0219-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><![CDATA[<div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/screenshot/%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB-480.webp 480w,/assets/img/screenshot/%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB-800.webp 800w,/assets/img/screenshot/%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/screenshot/%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="数组列表中的最大距离" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="知识点">知识点</h2> <ul> <li><code class="language-plaintext highlighter-rouge">abs()</code>函数：用来计算一个数的绝对值</li> </ul> <h2 id="解题思路">解题思路</h2> <ul> <li>由于给定的数组都是有序的，所以每个数组<code class="language-plaintext highlighter-rouge">i</code>的第一个元素<code class="language-plaintext highlighter-rouge">i[0]</code>都是该数组最小的元素，最后一个元素<code class="language-plaintext highlighter-rouge">i[i.size() - 1]</code>都是该数组最大的元素</li> <li>给定计算的最大距离的两个端点应该来自不同的数组，给定数组<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>，那么最大距离应该在<code class="language-plaintext highlighter-rouge">a[a.size() - 1] - b[0]</code>和<code class="language-plaintext highlighter-rouge">b[b.size() - 1] - a[0]</code>中出现。但是，遍历所有数组的时间复杂度容易造成超时</li> <li>考虑<strong>单次扫描</strong>数组，并跟踪更新目前为止找到的最小值点<code class="language-plaintext highlighter-rouge">min_val</code>和最大值点<code class="language-plaintext highlighter-rouge">max_val</code>，这些极值点可以被视为目前所有已经遍历过的数组的极值点</li> <li>对于一个新遍历到的数组<code class="language-plaintext highlighter-rouge">a</code>，我们可以将<code class="language-plaintext highlighter-rouge">a[n - 1] - min_value</code>与<code class="language-plaintext highlighter-rouge">max_value - a[0]</code>中的最大值与<code class="language-plaintext highlighter-rouge">res</code>进行比较，更新最大距离，并更新<code class="language-plaintext highlighter-rouge">min_value</code>和<code class="language-plaintext highlighter-rouge">max_value</code></li> <li>遍历结束后，返回<code class="language-plaintext highlighter-rouge">res</code></li> </ul> <h2 id="实现代码">实现代码</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">maxDistance</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">arrays</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">min_val</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">max_val</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arrays</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">),</span>
                               <span class="n">abs</span><span class="p">(</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])));</span>
            <span class="n">min_val</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_val</span><span class="p">,</span> <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="learning-notebook"/><category term="code"/><category term="algorithm"/><category term="leetcode"/><category term="每日一题"/><summary type="html"><![CDATA[记录每日一题的解题思路的求解代码]]></summary></entry></feed>